## 6.3.4. 消息处理
本节介绍了在客户端和服务器上的消息处理。请使用下面的图片来了解详细的成分认为，弥补客户端和服务器。

hopp2
当客户端发送消息，它采用客户端渠道公布。客户端检索通过从客户端会话的客户端通道 ClientSession.getChannel（字符串）。消息首先通过扩展，处理消息一个接一个; 如果一个延伸否认消息的处理中，将被删除，它不会被发送到服务器。在扩展处理结束时，该消息传递给客户端传输。

客户端传输的邮件转换为JSON（用于Java客户端，这是由一个做JSONContext.Client实例，参见JSON的部分），建立与服务器的运输管道，然后发送JSON字符串在管道，作为有效载荷传输特定的包络（例如，HTTP请求或一个WebSocket的消息）的。

包络传播到服务器，其中服务器传输接收它。该服务器传输转换从JSON格式返回给消息对象的消息（通过JSONContext.Server实例，参见JSON的部分），然后将它们传递给BayeuxServer处理实例。

该BayeuxServer处理每个消息中的以下步骤：

它调用BayeuxServer扩展（方法RCV（）或rcvMeta（））; 如果一个延伸拒绝处理，应答被发送到客户端指示该消息已被删除，并且该消息不执行任何进一步的处理。

它调用的ServerSession扩展（方法RCV（）或rcvMeta（） ，只有一个的ServerSession该客户端存在的话）; 如果一个延伸拒绝处理，应答被发送到客户端指示该消息已被删除，并且该消息不执行任何进一步的处理。

它调用授权检查为安全策略和授权人; 如果授权被拒绝，应答被发送到客户机，指示该故障，并且该消息不执行任何进一步的处理。

如果消息是一个服务或广播消息，该消息通过传递 BayeuxServer扩展（方法send（）方法或sendMeta（） ）。

它调用服务器通道侦听器; 该应用程序将服务器上的服务器通道侦听器，并提供了最后的机会来修改该消息之前它最终被发送到所有用户（如果它是一个广播消息）。所有的用户看到任何修改的服务器信道监听器使得该消息，就好像出版商已发送的消息已经修改。服务器通道侦听器进行处理后，该消息被冻结，并没有进一步的修改应作出的消息。应用程序不应该担心这个冷冻步骤，因为API澄清该消息是否是可修改与否：原料药有作为参数可修改的消息接口或修改的一个代表消息对象。这个步骤是用于传入非广播消息的最后加工步骤，因此，结束其行程的服务器上。的回复发送给出版商，以确认该消息做了它对服务器（见下文），但该消息未广播到其他服务器会话。

如果消息是一个广播消息，对于预订了通道的每个服务器会话，通过消息传递的ServerSession扩展（方法 send（）方法或sendMeta（） ），那么服务器会话队列监听器被调用，最后的消息被添加到服务器会话队列进行传送。

如果消息是一个懒惰的消息（参见懒惰的消息部分），它被发送的第一次。否则，该消息被立即传递。如果到该消息被排队的服务器会话对应一个远程客户端会话时，它被分配一个线程通过服务器传输，提供在其队列中的消息。服务器传输水渠服务器会话的消息队列，该消息转换为JSON，并将它们发送到管路作为传输特定的信封的有效载荷（例如，HTTP响应或一个WebSocket的消息）。否则，到该消息被排队的服务器会话对应一个本地会话，并在其队列中的消息直接传递到本地会话。

对于广播和非广播消息，将创建一个应答消息，经过BayeuxServer扩展和的ServerSession扩展（方法send（）方法 或sendMeta（） ）。然后将其传递给服务器传输，这通过将其转换为JSON JSONContext.Server实例（参见JSON的部分），并将其发送到该导管作为传输特定的包络的有效载荷（例如，HTTP响应或一个WebSocket的消息）。

信封旅行返回给客户端，客户端传输接收它。客户端传输从JSON格式返回给消息对象转换成消息，通过Java客户端JSONContext.Client实例（参见JSON的部分）。

每个消息然后通过扩展传递（方法send（）方法或sendMeta（） ），和通道侦听器和用户通知消息。

从客户端的往返服务器返回到客户端现已完成。
