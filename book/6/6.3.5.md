## 6.3.5. 线程
当收到服务器贝叶消息，一个线程被分配来处理消息和服务器端监听器在这个线程调用。该CometD实现不产生新的线程来调用服务器端的听众; 在这样的线程模型是保持简单，非常类似于Servlet的线程模型。

这个简单的线程模型意味着，如果一个服务器端监听器需要很长的时间来处理该消息并返回控制到执行，再执行无法处理，可能会到达下一个讯息，最常停止整个服务器处理。

这是因为，一个贝叶客户端使用的连接数量有限的与服务器进行交互的事实。如果发送给一个连接的消息都在服务器上进行处理的时间长了，客户端可能会在该连接上发送更多的消息，但这些不会被处理，直到前面的消息处理结束。

因此，这是很重要的，如果应用程序知道该消息可以触发一个耗时的任务（例如，数据库查询），它这样做在一个单独的线程。

服务（参见Java服务器服务部分）是一种简单的方法来设置服务器端监听器，但共享与正常服务器端监听器相同的线程模型：如果他们需要执行耗时的任务，他们需要做这样一个单独的线程，例如：

@服务
公共 类 为MyService
{
    @注入
    私人 BayeuxServer bayeuxServer;
     @会话
    私人 LocalSession localSession;

    @监听器（“ /服务/查询“）
     公共 无效 processQuery（最后的ServerSession remoteSession，最终 ServerMessage消息）
    {
        新的 主题（）
        {
            公共 无效的run（）
            {
                地图 < 字符串，对象 >数据= performTimeConsumingTask（消息）;

                / /发送数据到客户端一旦费时的任务完成
                remoteSession.deliver（localSession，message.getChannel（），responseData）;
            }
        。} start（）的;
    }
}
