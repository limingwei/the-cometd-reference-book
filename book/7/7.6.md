## 7.6. 消息配料
通常，应用程序需要发送多封邮件到不同的信道。这样做的一个天真的方式如下：

/ /警告：非最佳代码 
cometd.publish（' /通道1 '，{ 产品：' 富' }）;
cometd.publish（' /通道2 '，{ notificationType：' 所有' }）;
cometd.publish（' /通道3 '，{ 更新：假 }）;
你可能会认为，这三个出版离开客户一个接一个，但事实并非如此。请记住，发布（）是异步的（它会立即返回），所以三 发布（）的调用序列前一个字节到达网络可能返回好。第一个发布（）立即执行，而其他两个是在队列中，等待第一个发布（）来完成。一个发布（）完成时，服务器接收到它，发回的元响应，并在客户端收到该发布的元响应。当第一个发布完成时，第二次公布执行，并等待完成。在此之后，第三个发布（）最终执行。

如果设置称为配置参数autoBatch为true，则执行自动分批已排队的消息。在上面的例子中，第一发布（）立即执行，并且在完成时，执行批处理，第二和第三发布（）为一个请求到服务器。该autoBatch功能有趣的是那些收到异步的和不可预知的事件系统-无论是在以很快的速度或在暴-最终生成发布（）到服务器：在这种情况下，使用批处理API是不是有效的（因为每个事件将只产生一个发布（） ）。一阵在客户端上的事件产生了一阵发布（）给服务器，但autobatch机制自动分批他们，使沟通更高效。

排队机制避免排队一个发布（）后面的长轮询。如果没有这个机制，浏览器会接受三公布的要求，但它只有两个可用的连接，和一个已经占用的长轮询请求。因此，浏览器可能会决定循环赛发布请求，从而使先发布进入第二个连接，这是免费的，它实际上是通过网络发送，（记得，第一次连接已经忙于长轮询请求），排在第二发布到第一个连接（长轮询返回后），并计划再次发布第三到第二连接，后的第一个发布的回报。其结果是，如果你有五分钟的长轮询超时，第二个可能比第 ​​一和第三个发布请求五分钟后到达服务器发布请求。

您可以优化这三个发布使用配料，这是一种对消息进行分组在一起，使一个单一的贝叶消息实际上带有三个发布消息。

cometd.batch（函数（）
{
    cometd.publish（' /通道1 '，{ 产品：' 富' }）;
    cometd.publish（' /通道2 '，{ notificationType：' 所有' }）;
    cometd.publish（' /通道3 '，{ 更新：假 }）;
}）;

/ /或者，但不推荐：
cometd.startBatch（）
cometd.publish（' /通道1 '，{ 产品：' 富' }）;
cometd.publish（' /通道2 '，{ notificationType：' 所有' }）;
cometd.publish（' /通道3 '，{ 更新：假 }）;
cometd.endBatch（）
请注意这三个发布（）调用都传递给一个函数内一批（） 。

或者，但建议少，你可以围绕这三个发布（）调用之间startBatch（）和endBatch函数（） 。

记得打电话endBatch函数（）调用后startBatch（） 。如果你不这样做-例如，因为一个异常被抛出该批次的中间-你的消息将继续排队，并如预期般您的应用程序无法正常工作。
如果你仍然想使用风险startBatch（）和endBatch函数（）的调用，记住，你必须从执行相同的情况下这样做; 消息配料并没有被设计为跨越多个用户的交互。例如，那就大错特错了，开始批量在泛函（通过用户交互触发），并结束该批次的functionB（也由用户交互触发的，而不是调用泛函）。同样的，那就大错特错了，开始批量在泛函，然后调度（使用的setTimeout（））functionB的执行结束批次。功能批次（）已经做了正确的配料为你（也错误的情况下），所以它是推荐的方式做消息配料。

当批处理启动时，后续的API调用不被发送到服务器，而是排队，直到批次结束。该批处理结束包了所有排队的消息到一个单一的贝叶消息，并将通过网络向贝叶服务器。

消息配料允许高效使用网络：不是拍三级请求/响应周期，配料中只提出一项请求/响应周期。

批可以由不同的API调用：

无功 _subscription;
cometd.batch（函数（）
{
    cometd.unsubscribe（_subscription）;
    _subscription = cometd.subscribe（' /富'，函数（消息）{...}）;
    cometd.publish（' /酒吧'，{...}）;
}）;
贝叶服务器进程在它们被发送的顺序分批消息。
